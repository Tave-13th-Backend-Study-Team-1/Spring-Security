# Section 13.

### KeyCloak
- 키클락이란 인증 서버를 제공해주는 서비스로 바로 사용할 수 있는 구축된 서버를 제공한다.
- 키클락 외에도 Okta, ForgeRock, Amazon Congnito등에서 인증 서버를 제공해준다.
- 키클락은 오픈소스로서 비용이 들지 않음에도 불구하고 안정적이며 주기적인 업데이트가 이뤄진다.
- 외에도, 액세스 토큰 발급, SSO 기능(하나의 인증서버를 통해 다른 모든 어플리케이션에 접근 가능하도록 하는 기능) 제공, 소셜 로그인 기능, 중앙 제어 기능 등등을 제공한다.

#### KeyCloak 설치 방법
- 사이트에서 파일을 다운받은 뒤 터미널에서 bin/kc.bat start-dev로 실행하면 된다.
- 이제 port번호 8080 으로 실행될 것이며 localhost 8080으로 접속하면 관리자 계정을 생성하고 여러가지 권한을 수정할 수 있다.

#### Keycloak의 여러가지 권한
- 우선 keycloak에 로그인하면 Master realm이란 페이지가 나온다. 여기서 realm이란 인증 서버 내의 공간을 의미한다. 해당 공간에서 user, role, client를 생성할 수 있다.
- Master realm은 모든 어플리케이션을 관리하는 공간이다. 하지만 모든 어플리케이션을 한 곳에서 관리하면 확장성이 매우 떨어진다. 따라서 각각의 어플리케이션마다 realm을 따로 만들어 어플리케이션마다 다른 권한과 역할을 부여해주는것이 효율적이다.
- 따라서 우리 어플리케이션에 적합한 새로운 realm을 생성해야한다.
- 새로운 realm을 생성했으면 내부에서 클라이언트, 역할, 사용자, 그룹등을 원하는만큼 만들 수 있다.
- 위의 방법들을 따라하면 인증 서버를 성공적으로 구축할 수 있다.

### Api간 소통 시나리오
- client credentials grant type flow로 엔드유저가 연관돼있지 않은 시나리오다.

#### 인증 서버에 client 등록하기
- 우선 클라이언트 어플리케이션에서 인증 서버에 보내줄 client 정보를 받아야한다. 그러므로 keycloak 인증 서버에 클라이언트를 등록해보자.
- 우선 eazybank realm에 들어가고 client 메뉴에 들어가면 원하는 만큼 client를 등록할 수 있다.
!(키클락)[키클락예시.png]
 - 이 시나리오에선 우리가 직접 등록을 하지만 실제에서는 서드 파티에서 요청을 하고 내부 로직에서 타당한지 검사한 후에 keycloak에 클라이언트 등록을 해주는 방식으로 동작해야할것이다.
- 클라이언트 생성을 해보자 먼저 oauth2인지 openid connect 인지 설정해주고 그 다음엔 클라이언트 secret을 통한 인증을 진행할 것인지 정해줘야한다. 이후 인증 유형을 정해줘야한다.
!(클라이언트)[클라이언트예시.png]
- 위에서 standard flow는 authentication code flow를 의미하므로 해제 해준다. 우리는 client credentials grant type을 사용할 것이니 Service accounts roles를 선택해준다.
- 이제 저장을 해주면 클라이언트 secret을 확인할 수 있다.

#### 리소스 서버 구축하기
- 우선 백엔드 어플리케이션을 리소스 서버로 동작하게 만들기 위해선 다음과 같은 의존성이 필요하다.
```java
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
		</dependency>
```
- 위 의존성을 추가하면 백엔드 어플리케이션은 리소스 서버처럼 행동하며, api를 요청하는 유저에게 액세스 토큰을 요청하게 된다.
- 이제 액세스 토큰에서 유저의 정보를 추추하여 백엔드에서 이해할 수 있는 형식으로 바꿔줄 클래스를 만든다.
```java
public class KeycloakRoleConverter  implements Converter<Jwt, Collection<GrantedAuthority>> {
```
- 클래스는 다음과 같이 jwt 토큰을 GrantedAuthority 컬렉션으로 반환하는 Converter를 구현해야한다.
- 해당 인터페이스는 다음과 같은 메소드를 오버라이드 해야한다.
```java
@Override
    public Collection<GrantedAuthority> convert(Jwt jwt) {
        Map<String, Object> realmAccess = (Map<String, Object>) jwt.getClaims().get("realm_access");

        if (realmAccess == null || realmAccess.isEmpty()) {
            return new ArrayList<>();
        }

        Collection<GrantedAuthority> returnValue = ((List<String>) realmAccess.get("roles"))
                .stream().map(roleName -> "ROLE_" + roleName)
                .map(SimpleGrantedAuthority::new)
                .collect(Collectors.toList());

        return returnValue;
    }
```
- jwt.getClaims를 통해 이름이 realm_access인 Map을 가져온다.
- 이후 이름이 roles인 모든 객체를 반환시켜 리스트로 만들어 반환한다.
- 이제 defaultSecurityFilterchain 내부에 다음과 같은 코드를 통하여 우리가 만든 컨버터를 인식할 수 있게 만들어줘야한다.
```java
JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(new KeycloakRoleConverter());
```
- 이제 아래와 같은 코드로 리소스 서버의 기능을 수행하도록 설정해준다.
```java
.requestMatchers("/user").authenticated()
                        .requestMatchers("/notices","/contact","/register").permitAll())
                .oauth2ResourceServer(oauth2ResourceServerCustomizer ->
                        oauth2ResourceServerCustomizer.jwt(jwtCustomizer -> jwtCustomizer.jwtAuthenticationConverter(jwtAuthenticationConverter)));
```
- 아까 만들어둔 jwtAuthenticationConverter도 등록해주며 jwt 액세스 토큰을 활용할 것이라고 알려준다.
- 리소스 서버의 api는 모든 입력 파라미터를 id 에서 email로 바꿔야한다. 왜냐하면 서드 파티 어플리케이션에서는 절대로 해당 유저의 id를 알 수 없기 때문이다.
- 이제 application.properties에 인증 서버의 url을 남겨줌으로서 인증서버에서 액세스 토큰과 관련된 인증서를 다운받아 액세스 토큰을 검증할 수 있다.
  - 인증서에는 키 값이 저장돼 있고 해당 키 값을 통해 서명 부분을 해석하여 토큰이 조작되지 않았는지도 리소스 서버에서 확인이 가능하다.

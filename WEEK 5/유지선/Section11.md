# Section 11

## 보안 로직 분리

- 여러 개의 웹 애플리케이션에 같은 보안 로직을 구성하려는 경우
- 보안 로직, 인증, 허가 로직을 항상 분리
  - 공통 컴포넌트로 구성

## OAuth2

### 특징

- 업계 표준
- 인증과 허가 실행

### OAuth2가 해결해주는 점

- OAuth2를 사용하지 않을 때

  - 특정 애플리케이션의 정보를 기반으로 서비스에서 사용할 때 이용 \
    -> 동일한 계정에 대한 인증서를 사용하여 정보를 가져올 수 있음 \
    -> 제공한 인증서를 통하여 중요한 정보가 변경될 수 있음

- OAuth2를 사용할 때
  - 실제 인증서가 아닌 임시적인 접근을 허용할 수 있는 방안으로 사용 가능
    - 임시적인 접근 토큰 부여 (제한된 접근 허용)
  - 별개의 공통된 인증 서버 사용 \
    -> 모바일과 웹과 같이 다르더라도 인증 로직은 같이 적용할 수 있음

### OAuth2 정의

- Open Authorization
- 2의 경우 version 2를 이미
  - OAuth 2.0은 자유 오픈소스 프로토콜
- 한 애플리케이션이 다른 애플리케이션 내부에 있는 사용자의 데이터에 접속할 권한 부여
- 엑세스 토큰을 이용하여 이용 서비스의 허가 부여 가능
  - 가질 수 있는 권한 종류
  - 허가를 내릴 수 있는 종류

### Grant Type

- 인증의 한 종류
- 엑세스 토큰을 얻는 방식
- 엔드 유저나 애플리케이션에 대한 승인
- grant type 사용 시 엑세스 토큰 발급
- 종류
  - Authorization Code
  - PKCE
  - Client Credentials
  - Decive Code
  - Refresh Token
  - Implicit Flow (Legacy)
  - Password Grant (Legacy)

> **OAuth version 최신 정보 사이트** \
> oauth.net/2

### OAuth2 용어

- 리소스 소유자
  - 서비스를 이용하는 엔드유저
  - 엔드 유저의 리소스들이 제 3 애플리케이션에 보유
- 클라이언트
  - 가져오려는 사용자의 리소스들이 보관된 애플리케이션
  - 제 3의 애플리케이션
- 승인 서버
  - 리소스 소유자에 대해 알고 있는 서버
    - 인증서를 통하여 알고 있음
- 리소스 서버
  - 리소스가 저장되는 서버
  - 소규모 서비스의 경우 리소스 서버와 승인 서버가 병합된 상태
- 스코프
  - OAuth2 프로토콜 내에서 클라이언트가 원하는 세분화된 허가 ex) 트윗 읽기
  - 엑세스 권한을 요청할 때 사용하는 매개변수

## OAuth2 Sample Flow

- 엔드 유저에게 엑세스 토큰을 얻는 방법
  - OAuth2 구조물 따르기
  - 동일한 엑세스 토큰을 넘겨야 함

### 등록 흐름

1. 제 3의 애플리케이션에 클라이언트로 등록
   - 기본 정보에 대한 검사 진행
   - 모든 인증 완료 이후 정보 제공
     - 클라이언트 ID
     - 클라이언트 기밀 제공
2. 웹에서의 마케팅
   - 애플리케이션을 통한 로그인 가능 버튼 제공 \
     -> 애플리케이션 로그인 페이지로 리다이렉트
3. 리소스 소유자가 보닌의 인증서를 3의 애플리케이션 페이지에 작성 \
   -> 성공적인 인증 이후 허가 페이지를 보이며 리소스 공유에 대한 허락을 구함 (읽기 모드) \

4. 승인 서버가 엑세스 토큰과 리프레시 토큰 발급 \
   -> 엑세스 토큰으로 리소스 서버에 의해 관리되는 REST APIs를 실행하고 응답받을 수 있음

5. 클라이언트 애플리케이션이 원하는 리소스를 받아옴

## Grant Types

### 장치 코드 인증 유형

- Apple TV나 Android TV와 같은 장치에만 사용되는 인증 유형
- 브라우저나 키보드는 연관되어 있지 않음

## 인증 코드

1. 유저 -> 클라이언트
   - 자신의 리소스 요청
2. 클라이언트 -> 유저
   - 인증 서버로의 접근이 필요하다고 알림
3. 유저 -> 인증서버
   - 자신의 인증 정보를 넘겨 승인 코드를 받음
4. 인증서버 -> 클라이언트
   - 클라이언트에게 유저가 리소스를 허락했다고 알림
   - 인증코드 넘겨줌
   - 엔드 유저의 정보를 클라이언트에 넘기지 않음
5. 클라이언트 -> 인증 서버
   - 클라이언트 인증서를 통하여 클라이언트 검증
   - 인증 코드를 제시하여 검증
     - 매우 짧은 시간동안 유지
6. 인증 서버 -> 클라이언트
   - 클라이언트 검증 이후 엑세스 토큰 반환
7. 클라이언트 -> 리소스 서버
   - 받은 엑세스 토큰으로 리소스 서버에 접근 \
8. 리소스 서버 -> 클라이언트
   - 요구했던 리소스 모두 반환

- 스코프의 세부사항
  - CSRF 토큰과 유사한 동작 수행
  - 클라이언트에서 무작위 생성

### 인증을 위한 dto 세부사항

- 인증 코드 요청을 위한 데이터

  - `client_id`
  - `redirect_uri`
  - `scope`
  - `state`
  - `response-type`

- 인증 코드를 통한 엑세스 토큰 요청 데이터
  - `code`
  - `client_id `, `client_secret`
  - `grant_type`
  - `redirect_uri`

### 클라이언트의 두 번 요청 이유

- 인증 코드를 위하여
  - 인증서버가 사용자가 인증서와 함께 상호작용 했는지 확인
  - 세부 정보가 정확하고 리소스 소유자가 유효한 경우 인증 코드 발급
- 접근 코드를 위하여
  - 클라이언트의 신원 증명

## 암시적 인증 방식

### 특징

- 덜 안전하고 사용되지 않음
  - 인증 코드 유형 플로우를 더 많이 사용
- OAuth2 버전에서 완전한 제거 예정

### 인증 흐름

1. 유저 -> 클라이언트
   - 자신의 리소스를 원함
2. 클라이언트 -> 유저
   - 인증 서버로의 리다이렉션
3. 유저 -> 인증 서버
   - 인증서 및 본인 허가 증명
   - 보내는 데이터
     - `client_id`
     - `redirect_id`
     - `scope`
     - `state`
     - `response_type`
   - GET 요청으로 진행 \
     -> url에 있는 요청 내ㅐ용이 모두 노출
4. 인증 서버 -> 클라이언트
   - 엑세스 토큰을 넘김
5. 클라이언트 -> 리소스 서버
   - 요구하는 리소스 정보를 가져옴

### 단점

- GET요청으로 uri를 통해 토큰을 받아옴 \
  -> 토큰 탈취 가능성 존재 \
  -> 보안이 약함

## 비밀번호 부여 유형

### 흐름

1. 유저 -> 클라이언트
   - 자신의 리소스 사용을 요청
   - 자격 증명 입력
2. 클라이언트 -> 인증 서버
   - 입력한 자격 증명을 토대로 서버에게 로긴 요청을 보냄
   - 자격증명이 공유되어 추천되지 않는 유형
3. 인증 서버 -> 클라이언트
   - 엑세스 토큰 부여
4. 클라이언트 -> 리소스 서버
   - 엑세스 토큰을 이용하여 접근 가능
5. 리소스 서버 -> 클라이언트
   - 요청한 리소스 가져오기

### 특징

- 보통 클라이언트 애플리케이션, 인증 서버, 리소스 서버가 모두 한 단체에 속해 있을 경우 사용

## 클라이언트 인증에서의 grant type 플로우

- 엔드 유저가 연관되어 있지 않음
  - 클라이언트, 인증 서버, 리소스 서버
- 두개의 백엔드 애플리케이션이나 두 개의 microservices 애플리케이션이 서로 소통하려 할 때 사용
  - 각각이 서로 다른 단체에 소속

### 흐름

1. 클라이언트 -> 인증 서버
   - 클라이언트 자격 증명 제시 후 리소스에 대한 엑세스 요구
   - 데이터
     - `client_id`
     - `client_secret`
     - `scope`
     - `grant_type` : client_credentials
       - 엔드 유저가 연관되어 있지 않다는 것을 인지
2. 인증 서버 -> 클라이언트
   - 클라이언트에게 엑세스 토큰 적용
3. 클라이언트 -> 리소스 서버
   - 엑세스 토큰으로 리소스를 얻기 위하여 접근
4. 리소스 서버 -> 클라이언트
   - 엑세스 토큰 검증 이후 원하는 리소스 반환

## 토큰

- 결과로 받은 데이터 정보

```
{
  "token_type": "Bearer",
  "expires_in": 86400,
  "access_token": "_Kjh_44iv6rc_387gZJ_jsfWHeDDEkDbc_kaRWBdTt6t_gyQX6vX63k10yU0vNkK_JcDtrhb",
  "scope": "photo offline_access",
  "refresh_token": "LM-_ewSHc350DuEB3MELMHFB"
}
```

- expires_in
  - 엑세스 토큰의 다음 날짜까지의 유효기간
  - 86400초 : 24시간
- 리프레시 토큰 적절할 시 인증 서버는 새로운 유효 기간을 가진 새로운 엑세스 토큰 부여
- 새로운 리프레시 토큰에서도 발급

### 리프레시 토큰 유형 플로우

1. 클라이언트 -> 리소스 서버
   - 리소스 서버에 엑세스 토큰으로 접근 시도
   - 엑세스 토큰의 만료 사실을 모르는 상태
2. 리소스 서버 -> 클라이언트
   - 엑세스 토큰 만료 \
     -> error 403 forbidden 반환
3. 클라이언트 -> 인증 서버
   - 엑세스 토큰이 새로 필요하다고 요구
   - 리프레시 토큰 이용
   - 데이터
     - `client_id`
     - `client_secret`
     - `refresh_token`
     - `scope`
     - `grant_type` : refresh_token
4. 인증 서버 -> 클라이언트
   - 리프레시 토큰 검증 이후 엑세스 토큰 발급
5. 클라이언트 -> 리소스 서버
   - 발급받은 엑세스 토큰으로 리소스를 다시 받아옴

- 엔드 유저와 연관되지 않아야 함
- 리프레시 토큰의 사용 이유
  - 엑세스 토큰만 사용시 탈취 당할 때 문제 발생 가능

## 리소스 서버에서의 엑세스 토큰 검증 방법

### 1. 승인 서버와 리소스 서버 간 직접적인 api 교류

- 리소스 서버가 엑세스 토큰을 부여받음 \
  -> 승인 서버에 의해 노출된 api중 하나 실행 \
  -> 승인 서버가 접근 토큰이 적절하다고 확인 \
  -> 리소스 서버는 클라이언트에게 긍정적 답변 송신
- 엑세스 토큰을 통해 받는 요청마다 승인 서버 실행 필요 \
  -> 불필요한 교통 체증 발생 / 접근이 원활하지 않을 수 있음

### 2. 승인 서버와 리소스 서버가 공통 데이터베이스 사용

- 승인 서버는 엑세스 토큰을 클라이언트로 발급할 때마다 데이터베이스의 엔트리 생성
- 클라이언트로부터 동일한 엑세스토큰 수신 \
  -> 리소스 서버는 공유되는 데이터베이스를 통하여 질문 가능

### 3. 리소스 서버가 승인 서버와 연결

- 승인 서버로부터 공개 인증서를 받을 수 있음
- 인증 서버로부터 발급되는 엑세스 토큰을 받을 때마다 조작 진위 여부 판단 가능
  - 공개 키 사용
- 인증 서버와 리소스 서버간의 지속적인 소통이 존재하면 안 됨
  - 첫 번째 시도에만 서버끼리의 연결
    - 인증 서버로 부터 공개 인증서를 받기 위하여

## OIDC (OpenID Connect)

### OAuth2 vs OIDC

- OAuth2
  - 승인이 필요한 상황마다 엑세스 토큰을 발급 받고 스코프를 통해 승인 강화
    - 클라이언트에서 엔드 유저에 대한 허가 이해 가능
  - 파악을 못하는 정보 존재
    - 엔드 유저의 정보
    - 디테일 정보
    - 이메일 정보
    - 주소 세부 사항 정보
- **OIDC**
  - OAuth 2.0 구조물 위에서 작동되는 프로토콜 (감싸기)
    - OAuth 2.0 구조물을 사용하지 않음
    - OAuth 2.0 구조물 자체도 인식 불가능
  - 엔드 유저에 대한 세부 사항 추가 파악 가능

### OIDC 구조물

- HTTP 프로토콜 위에 존재
  - 엑세스 토큰의 도움을 얻어 승인하는 역할 수행
- OpenID Connect
  - 권한과 인증을 모두 받을 수 있음
  - OpenID 연결을 실행할 때마다 두 가지 토큰 종류 발생
    - 엑세스 토큰 : 승인 관리
    - ID 토큰 : 사용자의 세부사항 권한 관리

### OpeniD 연결을 승인 서버와 함께 시작하는 방법

- 스코프 안에 OpenID라는 값을 보내기
- 인증 서버로 요청에 해당되는 특별한 스코프 전송 \
  -> 인증 서버가 인지하면 엑세스 토큰과 ID토큰을 동시에 보낼 수 있는 기능 보유
- IAM 과 접근관리 \
  => 엔드 유저의 정보 식별과 접근 관리 강화 가능

### IAM

- OpenID 연결과 OR two 구조물에서 이용하는 개념
- 어떤 토큰을 활용할 것인지는 개발자가 결정 가능

### OpenID 연결

- 사용자 디테일을 ID토큰 형태로 공유 가능
  - OpenID 프로필, 이메일, 주소와 같은 스코프 존재 \
    -> 엔드 유저의 세부 사항을 이해하기 쉽게 만들어줌
- ID토큰을 JWT형태로 저장 가능
- OpenID 연결을 사용하는 모든 인증 서버들은 엔드 포인트 노출
- 클라이언트가 언제든지 실행할 수 있는 사용자 마련

# Section 3.
- 이제 jdbcUserDetailsManager가 아닌 우리만의 로직으로 UserDetails를 정의해보겠다.
- 우선 LoadUserByUsername 메소드를 직접 작성해야한다.
- 그러기 위해 데이터베이스에서 유저 정보를 가져와 UserDetails 객체로 만들어 반환해주는 로직을 작성해줘야한다.
```java
public class EazyBankUserDetails implements UserDetailsService {
```
- 다음과 같이 UserDetailsService를 구현하여 만든다.

```java
@Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        String userName, password;
        List<GrantedAuthority> authorities;
        List<Customer> customer = customerRepository.findByEmail(username);
        if (customer.size() == 0) {
            throw new UsernameNotFoundException("User details not found for the user : " + username);
        } else{
            userName = customer.get(0).getEmail();
            password = customer.get(0).getPwd();
            authorities = new ArrayList<>();
            authorities.add(new SimpleGrantedAuthority(customer.get(0).getRole()));
        }
        return new User(userName,password,authorities);
    }
```
- 위는 구현한 코드다 findByEmail 메소드를 통해 유저 정보를 가져오고 추출한 유저의 정보를 바탕으로
- User 객체를 생성한다. User 객체 생성자는 두 가지 유형이 있었는데 그 중 첫 번째를 사용했다.
- 생성된 객체는 DaoAuthenticationProvider에게 넘어간다.
- DaoAuthenticationProvider에선 유저에게 받은 비밀번호와 데이터베이스에서 가져온 비밀번호를 비교한다.
- 이제 EazyBankUserDetails를 Bean으로 등록해놓으면 스프링 시큐리티는 인증을 진행할 때 UserDetails의 구현체로 EazyBankUserDetails를 선택할 것이다.

# 데이터베이스 유저 등록 API
- 스프링 시큐리티의 기본 설정은 CSRF 공격을 막기위해 데이터베이스에 접근하는 모든 post 요청을 막아놨다.
-         http.csrf((csrf) -> csrf.disable())
- 다음과 같이 csrf를 해제해 놓아야 post 요청이 들어간다. 자세한 내용은 추후에 다룬다.

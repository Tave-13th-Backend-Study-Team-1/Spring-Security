# Section 3.
### UserDetailsService 커스텀
- 이제 jdbcUserDetailsManager가 아닌 우리만의 로직으로 UserDetails를 정의해보겠다.
- 우선 LoadUserByUsername 메소드를 직접 작성해야한다.
- 그러기 위해 데이터베이스에서 유저 정보를 가져와 UserDetails 객체로 만들어 반환해주는 로직을 작성해줘야한다.
```java
public class EazyBankUserDetails implements UserDetailsService {
```
- 다음과 같이 UserDetailsService를 구현하여 만든다.

```java
@Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        String userName, password;
        List<GrantedAuthority> authorities;
        List<Customer> customer = customerRepository.findByEmail(username);
        if (customer.size() == 0) {
            throw new UsernameNotFoundException("User details not found for the user : " + username);
        } else{
            userName = customer.get(0).getEmail();
            password = customer.get(0).getPwd();
            authorities = new ArrayList<>();
            authorities.add(new SimpleGrantedAuthority(customer.get(0).getRole()));
        }
        return new User(userName,password,authorities);
    }
```
- 위는 구현한 코드다 findByEmail 메소드를 통해 유저 정보를 가져오고 추출한 유저의 정보를 바탕으로
- User 객체를 생성한다. User 객체 생성자는 두 가지 유형이 있었는데 그 중 첫 번째를 사용했다.
- 생성된 객체는 DaoAuthenticationProvider에게 넘어간다.
- DaoAuthenticationProvider에선 유저에게 받은 비밀번호와 데이터베이스에서 가져온 비밀번호를 비교한다.
- 이제 EazyBankUserDetails를 Bean으로 등록해놓으면 스프링 시큐리티는 인증을 진행할 때 UserDetails의 구현체로 EazyBankUserDetails를 선택할 것이다.

### 데이터베이스 유저 등록 API
- 스프링 시큐리티의 기본 설정은 CSRF 공격을 막기위해 데이터베이스에 접근하는 모든 post 요청을 막아놨다.
-         http.csrf((csrf) -> csrf.disable())
- 다음과 같이 csrf를 해제해 놓아야 post 요청이 들어간다. 자세한 내용은 추후에 다룬다.

# Section 4.

### PasswordEncoder에 관하여
- 비밀번호는 반드시 암호화하여 데이터베이스에 저장해야한다.
- AuthenticationProvider에서 실질적인 비밀번호 검증이 일어난다.
- 맨처음 DaoAuthenticationProvider에 User 객체가 넘어가면 preAuthenticationChecks 라는 메소드가 실행된다.
- 이 메소드에선 유저의 계정이 만료됐는지, 비밀번호는 유효한지 등등의 모든 시나리오를 검색해보고 모든 시나리오가 통과됐다면 additionalAuthenticationsChecks 메소드를 호출한다.
- additionalAuthenticationsChecks 메소드는 password검증이 일어나는 곳이다.
-  유저로부터 받은 Authentication 객체에서 비밀번호를 읽어낸다.
-  그리고 passwordEncoder에서 matches라는 메소드를 호출한다.
-  passwordEncoder의 mathches 메소드는 두 비밀번호가 일치하는지 확인해주는 메소드이며 만약 암호화가 돼있다면 복호화하여 두 비밀번호를 비교한뒤 일치하는지 아닌지를 반환해준다.

### Encoding이란
- 인코딩이란 데이터를 다른 형식으로 바꾸는 작업을 의미한다.
- 인코딩은 보안과 관련된 작업이 아니다. 그저 한국어를 미국어로 바꾸는 정도의 작업을 의미한다.
- 주로 음성 파일이나 영상 파일을 압축하여 저장할 때 사용된다.
- EX) ASCII, BASE64,UNICODE 등등,,

### Encryption이란 
- 일반 데이터를 암호화하여 저장하는 과정이다.
- 특정 암호화 알고리즘을 따르며 그 알고리즘에 비밀 키를 제공하면, 비밀 키를 활용하여 아무도 모르는 형식으로 암호화 시키는 것이다.
- 암호화된 비밀번호가 무엇인지 알고싶다면 다시 Decryption을 진행해야 한다.
- 그러한 경우엔 동일한 알고리즘과 동일한 비밀키가 필요하다.
- 어떠한 알고리즘인지, 어떠한 비밀키인지는 백엔드 내부에 기밀 데이터로 관리된다.
- 만약 내부 기밀 데이터에 접근할 수 있는 사람이라면 이러한 비밀번호를 복호화 시키는 것은 어려운 작업이 아닐 것이다.
- Encryption은 내부 유저의 비밀번호는 암호화 시키지만, 엔드유저가 서버로 보내는 비밀번호는 암호화시키지 않기 때문에 충분한 대안은 아니라고 볼 수 있다.

### Hashing이

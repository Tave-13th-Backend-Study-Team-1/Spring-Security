# Section 3.
### UserDetailsService 커스텀
- 이제 jdbcUserDetailsManager가 아닌 우리만의 로직으로 UserDetails를 정의해보겠다.
- 우선 LoadUserByUsername 메소드를 직접 작성해야한다.
- 그러기 위해 데이터베이스에서 유저 정보를 가져와 UserDetails 객체로 만들어 반환해주는 로직을 작성해줘야한다.
```java
public class EazyBankUserDetails implements UserDetailsService {
```
- 다음과 같이 UserDetailsService를 구현하여 만든다.

```java
@Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        String userName, password;
        List<GrantedAuthority> authorities;
        List<Customer> customer = customerRepository.findByEmail(username);
        if (customer.size() == 0) {
            throw new UsernameNotFoundException("User details not found for the user : " + username);
        } else{
            userName = customer.get(0).getEmail();
            password = customer.get(0).getPwd();
            authorities = new ArrayList<>();
            authorities.add(new SimpleGrantedAuthority(customer.get(0).getRole()));
        }
        return new User(userName,password,authorities);
    }
```
- 위는 구현한 코드다 findByEmail 메소드를 통해 유저 정보를 가져오고 추출한 유저의 정보를 바탕으로
- User 객체를 생성한다. User 객체 생성자는 두 가지 유형이 있었는데 그 중 첫 번째를 사용했다.
- 생성된 객체는 DaoAuthenticationProvider에게 넘어간다.
- DaoAuthenticationProvider에선 유저에게 받은 비밀번호와 데이터베이스에서 가져온 비밀번호를 비교한다.
- 이제 EazyBankUserDetails를 Bean으로 등록해놓으면 스프링 시큐리티는 인증을 진행할 때 UserDetails의 구현체로 EazyBankUserDetails를 선택할 것이다.

### 데이터베이스 유저 등록 API
- 스프링 시큐리티의 기본 설정은 CSRF 공격을 막기위해 데이터베이스에 접근하는 모든 post 요청을 막아놨다.
-         http.csrf((csrf) -> csrf.disable())
- 다음과 같이 csrf를 해제해 놓아야 post 요청이 들어간다. 자세한 내용은 추후에 다룬다.

# Section 4.

### PasswordEncoder에 관하여
- 비밀번호는 반드시 암호화하여 데이터베이스에 저장해야한다.
- AuthenticationProvider에서 실질적인 비밀번호 검증이 일어난다.
- 맨처음 DaoAuthenticationProvider에 User 객체가 넘어가면 preAuthenticationChecks 라는 메소드가 실행된다.
- 이 메소드에선 유저의 계정이 만료됐는지, 비밀번호는 유효한지 등등의 모든 시나리오를 검색해보고 모든 시나리오가 통과됐다면 additionalAuthenticationsChecks 메소드를 호출한다.
- additionalAuthenticationsChecks 메소드는 password검증이 일어나는 곳이다.
-  유저로부터 받은 Authentication 객체에서 비밀번호를 읽어낸다.
-  그리고 passwordEncoder에서 matches라는 메소드를 호출한다.
-  passwordEncoder의 mathches 메소드는 두 비밀번호가 일치하는지 확인해주는 메소드이며 만약 암호화가 돼있다면 복호화하여 두 비밀번호를 비교한뒤 일치하는지 아닌지를 반환해준다.

### Encoding이란
- 인코딩이란 데이터를 다른 형식으로 바꾸는 작업을 의미한다.
- 인코딩은 보안과 관련된 작업이 아니다. 그저 한국어를 미국어로 바꾸는 정도의 작업을 의미한다.
- 주로 음성 파일이나 영상 파일을 압축하여 저장할 때 사용된다.
- EX) ASCII, BASE64,UNICODE 등등,,

### Encryption이란 
- 일반 데이터를 암호화하여 저장하는 과정이다.
- 특정 암호화 알고리즘을 따르며 그 알고리즘에 비밀 키를 제공하면, 비밀 키를 활용하여 아무도 모르는 형식으로 암호화 시키는 것이다.
- 암호화된 비밀번호가 무엇인지 알고싶다면 다시 Decryption을 진행해야 한다.
- 그러한 경우엔 동일한 알고리즘과 동일한 비밀키가 필요하다.
- 어떠한 알고리즘인지, 어떠한 비밀키인지는 백엔드 내부에 기밀 데이터로 관리된다.
- 만약 내부 기밀 데이터에 접근할 수 있는 사람이라면 이러한 비밀번호를 복호화 시키는 것은 어려운 작업이 아닐 것이다.
- Encryption은 암호화에 사용된 알고리즘과 비밀키 값만 알고있다면 비밀번호를 Decryption 할 수 있기에 문제가 있다.

### Hashing이란
- 해싱에서 우리의 데이터는 해시값으로 변환된다고 한다.
- 해시값만을 아는걸로 비밀번호를 평문으로 되돌릴 수 없기에 해싱은 업계 표준으로 사용되고 있다.
#### 그렇다면 엔드유저의 비밀번호는 어떻게 검증할까?
- 해싱을 통한 비밀번호 저장은 저장된 값을 다시 평문으로 되돌릴 수 없기에 엔드유저의 비밀번호를 해싱하는 과정에서 생성된 해시값과 데이터베이스에 저장된 해시값을 비교하여 검증한다.
- 데이터베이스를 해킹해서 해시값을 알아낸다고 하더라도, 평문으로 만들 수 없어 해킹해도 아무런 소용이 없다.
- 해싱 알고리즘은 같은 값을 해싱할때마다 다른 문자열을 반환한다 하지만 내부적으로는 같은 해시값을 갖고있게 만들어져있기 때문에 내부적으로 저장된 해시값을 통해 검증을 수행할 수 있다.
  - 각각의 다른 문자열들의 해시값이 모두 동일하다는 의미이다.
- 그렇게 해싱할 때마다 나오는 다른 문자열들과 데이터베이스에 저장된 문자열을 비교하여 해시값이 동일한지 비교하면 검증에 성공할 수 있다.

![해싱 흐름]()
1. 유저가 비밀번호를 입력한다.
2. 비밀번호를 해싱하여 문자열을 얻어낸다
3. UserDetails 객체에 저장된 해싱 문자열을 찾는다.
4. 문자열들의 해시값을 알아내어 두 해시값이 일치한다면 검증에 성공한다.


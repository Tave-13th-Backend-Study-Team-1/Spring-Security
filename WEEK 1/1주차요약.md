# 1주차 요약

## Chapter 1.  

#### spring security를 써야하는 이유는 무엇일까?  
1. 보안 전문가들이 개발한 spring security를 사용함으로서 우리는 비즈니스 로직에만 집중할 수 있다.
2. 최적화된 코드이기 때문에 최소한의 구성으로 웹 어플리케이션을 보호할 수 있다.
3. 발전해가는 CSRF,CORS등의 취약점에 대비해 spring security팀은 항상 보안 코드를 업데이트 한다.
4. 권한을 부여하여 접근을 제한할 수 있다.
5. 다양한 방법으로 인증 및 인가를 구현할 수 있다. (JWT, OpenId등,, 추후에 배움) 

#### Spring Security에서는 기본적으로 로그인 페이지가 주어지며, 아이디로 "user" 비밀번호로 "제공되는 비밀번호"를 입력하면 모든 URL에 접근할 수 있게 된다.

그렇다면 아이디와 비밀번호는 어떻게 바꿀 수 있을까? 

application.properties에서  
spring.security.user.name=ezybytes  
spring.security.user.password = 12345  

이와 같은 코드로 아이디와 비밀번호를 변경 가능하다. 하지만 이는 단순한 초기 설정 방식일 뿐이고,
**절대로** 운영환경에서는 이와 같이 사용해서는 안된다.

#### 서블릿과 필터
![서블릿](https://github.com/Tave-13th-Backend-Study-Team-1/Spring-Security/blob/junbeom/WEEK%201/img_folder/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-03-12%20175944.png)

모든 웹사이트는 http 프로토콜을 사용하여 소통한다.  
그러나 우리의 자바코드는 그러한 http 요청을 이해할 수 없기에 중재자가 필요하다.  
이 중개자를 우리는 서블릿 컨테이너라고 부른다.

서블릿의 컨테이너의 역할: http 요청 메세지를 자바 코드가 이해할 수 있는 서블릿 request object로 변환한다. 그리고 우리의 자바코드가 다시 response 메세지를 보낼 때 http 프로토콜로 감싸 호스트에게 보낸다.  

* 그러나 서블릿은 너무 복잡해서 이러한 서블릿을 활용하는 spring이 등장했고, spring에 Controller, MVC path등을 정의하면 spring 내부에서 서블릿을 생성하도록 설계되어 있다.

필터란 서블릿의 특별한 종류 중 하나로서 클라이언트화 서블릿 사이에서 오고가는 요청을 가로채 특정 작업을 선행할 수 있게 해주는 거름망을 의미한다.

* 추후에 이 필터를 활용하여 권한을 확인하고 권한이 없다면 접근을 막는 등의 역할을 수행할 수 있다.

  
#### Spring Security의 내부 흐름

![inner_flow](https://github.com/Tave-13th-Backend-Study-Team-1/Spring-Security/blob/junbeom/WEEK%201/img_folder/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-03-12%20174857.png)

post 요청으로 유저가 아이디와 비밀번호를 보낸다.
1. 서블릿 컨테이너로 들어가기 전 Spring Security에 포함된 필터에 요청이 들어간다.(필터는 URL을 확인 후 누구나 접근할 수 있는 URL인지 아닌지를 판별한다.) 20개 정도의 필터가 존재하며, 필터는 각각의 고유한 역할을 지니고 있다.
2. 필터에서 추출한 유저네임과 비밀번호를 가지고 Authentication 객체를 생성한다.         

  
* Principal: Principal은 현재 사용자를 나타내는 객체다. 주로 사용자의 식별 정보(예: 사용자 이름, 이메일 등)를 포함한다.

* Credentials: Credentials는 사용자의 자격 증명(예: 비밀번호)을 나타낸다. 주로 암호화된 형태로 저장되며, 일반적으로 보안상의 이유로 실제 값을 포함하지 않는다.

* Authorities: Authorities는 사용자에게 부여된 권한을 나타내는 컬렉션이다. 각각의 권한은 문자열 혹은 객체로 표현될 수 있다. 이를 통해 애플리케이션에서 사용자의 권한을 확인하여 접근 제어를 할 수 있다.

* Authenticated Flag: 인증된 사용자인지 여부를 나타내는 플래그이다. 사용자가 인증되었으면 true를, 그렇지 않으면 false를 가진다.  
현재 단계에서는 Principal과 Credential만을 보유하고 있다.
  
3. 이 Authentication 객체를 Authentication Manager에게 보낸다. 매니저는 적절한 Athentication provider가 무엇인지 확인하는 역할을 맡는다.
* Authentication Manager는 여러가지 provider 구현체를 가지고 있으며(데이터베이스에 저장된 것을 불러와 인증하는 로직, 서버에 저장된 것을 불러와 인증하는 로직, 메모리에서 불러와 인증하는 로직 등,,) 인자가 일치하는 Authentication Provider에게 객체를 전달하여 인증을 수행한다.

4. 만약 모든 provider에서 인증이 실패했을 경우 사용자에게 인증에 실패했다고 응답을 반환한다.
5. 

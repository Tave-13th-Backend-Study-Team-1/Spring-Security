# Section 3.

### 메모리에 유저 정보를 저장하는 첫 번째 방법 
- UserDetailsManager를 extends한 InMemoryUserDetailsManager클래스를 정의해주면 된다.
```java
@Bean
    public InMemoryUserDetailsManager userDetailsService(){
        UserDetails admin = User.withDefaultPasswordEncoder()
                .username("admin")
                .password("12345")
                .authorities("admin")
                .build();

        UserDetails user = User.withDefaultPasswordEncoder()
                .username("user")
                .password("12345")
                .authorities("read")
                .build();

        return new InMemoryUserDetailsManager(admin,user);
    }
```
위와 같은 코드에서 User.build()를 호출하면 유저의 세부사항이 담긴 User 객체를 생성할 수 있고, 이렇게 생성한 객체를
InMemoryUserDetailsManager의 생성자에 인자로 집어넣어 메모리에 저장할 수 있는것이다.

```java
public InMemoryUserDetailsManager(Collection<UserDetails> users) {
        Iterator var2 = users.iterator();

        while(var2.hasNext()) {
            UserDetails user = (UserDetails)var2.next();
            this.createUser(user);  // <---- 유저 생성
        }

    }
```

```java
public void createUser(UserDetails user) {
        Assert.isTrue(!this.userExists(user.getUsername()), "user should not exist");
        this.users.put(user.getUsername().toLowerCase(), new MutableUser(user)); <-- put 메소드를 통해 저장
    }
```

- 위의 실제 코드를 보면 다음과 같이 넘어온 유저의 정보를 저장하는 것을 확인할 수 있다.

### 메모리에 유저를 저장하는 두 번째 방법
- 두 번째 방법은 withDefaultPasswordEncoder()를 사용하지 않는다.
- 그 대신 Bean으로 NoOpPasswordEncoder를 등록해서 사용하는데, 이 방식은 비밀번호를 인코딩 하지 않고 String 그대로 저장하겠다는 의미이다.
- NoOpPasswordEncoder를 Bean으로 등록하면 모든 유저를 NoOpPasswordEncoder 방식으로 저장하겠다고 해석이된다.

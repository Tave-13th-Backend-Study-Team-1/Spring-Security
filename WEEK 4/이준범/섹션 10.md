# Section 10.

### 메소드 레벨 보안
- Spring Security에서 메소드 레벨 보안은 기본적으로 비활성화 되어있다.
- 메소드 레벨 보안의 활성화를 위해선 @EnableMethodSecurity라는 어노테이션을 사용해야한다.
- 해당 어노테이션은 클래스 위에 선언하여 메소드레벨 보안을 활성화시킬 수 있다.
- 해당 어노테이션 이외에도 다른 어노테이션들이 필요하다. 첫 번재 세트는 @preAuthorize, @postAuthorize이다.
  - 위의 어노테이션들을 사용하기 위해선 @EnableMethodSecurity 내부에서 (prePostEnabled =true)로 설정해야한다.
- @Secured를 사용하기 위해선 securedEnabled =ture, @RoleAllowed를 사용하기 위해선 jsr250Enabled = true로 설정해야한다.

### preAuthoirze 예시
- preAuthorize는 메소드가 호출되는 순간 조건을 비교하여, 조건에 부합하지 않는다면 메소드 호출 자체를 무효화 시킨다. 
```java
@preAuthorize("hasAuthority('VIEWLOANS')")
@preAuthorize("hasRole('ADMIN')")
@preAuthorize("hasRole('USER')")
@preAuthorize("# username == authentication.principal.username") //입력받은 유저네임과 인증객체에 저장 유저네임이 동일한지 확인하는 로직
public Loan getLoanDetails(String username){
    return loansRepository.loadLoanDetailsByUserName(username);
}
```
- 위와같이 여러가지 조건을 명시했을 경우 위의 조건들 중 하나라도 충족하면 밑의 클래스를 실행시킬 수 있다 즉 or의 개념으로 동작한다.

### postAuthorize 예시
- postAuthorize는 메소드의 호출을 막지않고 실행시킨다 다만, 메소드의 리턴값을 검사하여 조건에 부합하지 않는다면 리턴을 취소시킨다.
  ```java
@postAuthorize("returnObject.username == authentication.principal.username")
@postAuthorize("hasPermission(returnObject,'ADMIN')")
public Loan getLoanDetails(String username){
    return loansRepository.loadLoanDetailsByUserName(username);
}
```
- 요구사항이 너무 복잡하면 PermissionEvaluator라는 인터페이스를 implements하여 로직을 작성하도록 하자.
- 위의 메소드 레벨 보안은 Spring AOP에 의해 실현된다. 런타임 도중 메소드 호출을 인터셉트하여 주석 내의 조건을 먼저 검사하는것이다

### 예시

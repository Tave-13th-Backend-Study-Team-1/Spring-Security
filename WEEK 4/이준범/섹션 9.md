# Section 9.

### JSESSIONID 에 관하여
- jsessionid는 로그인시 자동으로 생성되는 쿠키로, 해당 쿠키가 저장되면 다시 보안api 요청시 재 로그인이 필요없다.
- 그러나 jsessionid는 작은 규모의 프로젝트에선 적합하지만 대규모의 프로젝트에서는 적합하지 않은데
  - 1. 해당 토큰은 유저 데이터를 갖고 있지 않다. (무작위로 생성된 값이기 때문에 유저 데이터를 넣을 수 없다.)
    2. 보안상 취약하여 브라우저에 저장된 해당 쿠키를 악용할 가능성이 높다.
  - 그렇기에 우리는 jsessionid 보다 더 나은 선택지를 찾아야한다.

### 토큰이란 무엇인가?
- 토큰이란 범용고유 식별자(UUID) 형식의 일반 문자열 또는 json web token 두 종류 중 하나이다.
- 해당 토큰들은 엔드 유저의 인증 작업이 완료되는 로그인 작업 중 처음으로 생성된다.
- 토큰은 생성된 후 프론트에 의해 보호된 api를 요청할 때마다 백엔드 시스템으로 같이 전달된다.

### 토큰 생성 흐름
1. 엔드 유저가 백엔드에 본인의 ID와 비밀번호를 입력한다.
2. 자격증명이 유효하다면 백엔드에서는 토큰을 생성한다. 이는 무작위로 생성되며 해당 토큰은 엔드 유저에게 반환된다.
3. 엔드 유저가 보안 api 요청을 한다. 이때 프론트에서는 받았던 것과 동일한 토큰을 백엔드에 보낸다.
4. 백엔드는 해당 토큰이 유효하다면 짜여진 로직에 의한 올바른 반응을 보일것이다.

### 토큰의 장점
1. 토큰을 이용하면 맨 처음 로그인 이후 재로그인을 할 필요가 없다. (자격증명이 불필요하게 네트워크에 노출되는 것을 막으며, 백엔드의 자격증명 로직이 실행되지 않기에 시간적으로도 이득이 된다.)
2. 해커가 네트워크의 특정 시간 모든 자격증명과 쿠키들을 훔쳤을 경우 토큰을 사용하는 경우엔 자격증명이 이뤄지지 않기에 해당 토큰만 무효화 시키면 되지만 만약 자격증명을 계속 이용하고 있었으면 모든 유저가 ID와 비밀번호를 바꿔야한다. (보안에 예민한 사이트일수록 토큰의 생명주기를 짧게 가져야한다.)
3. 토큰을 사용하여 유저의 정보 혹은 role을 저장할 수 있다.
4. 토큰을 재사용 할 수 있다. (구글메일, 구글 지도등 한 조직에서 운영하는 여러 어플리케이션 사이 토큰을 공유하여 자격증명을 생략할 수 있다.)
5. 유저의 정보를 하나도 저장하지 않아도 되는 statless 상태로 존재할 수 있다. 

### JWT 토큰에 관하여
- 내부적으로 데이터를 JSON 형태로 저장하기 때문에 json web token이라 한다.
- Rest 서비스의 도움으로 JSON 형식으로 소통하게 설계되었다.
- 가장 많이 사용되는 토큰이다.
- 인증 및 인가 사용이 가능하다.
- 토큰 내부에서 유저와 관련된 정보를 저장 및 공유할 수 있다.
- 서버쪽 세션 안에 유저에 대한 정보를 저장하고 있어야하는 부담을 줄여준다.

### JWT 토큰의 구조
- jwt 토큰은 헤더, 페이로드(바디), signature(서명)로 구분되며 이 세 가지는 .으로 구분된다, 헤더와 바디는 필수 부분이다.
![](jwt예시.png)
- 헤더는 토큰의 메타데이터 정보를 바디는 주로 알고리즘이 무엇인지, 토큰의 종류가 무엇인지, 토큰의 형식은 어떤 것인지 등의 정보를 담고있다.
- 주로 헤더와 바디의 JSON 형태를 BASE64형태로 인코딩하여 저장한다.
- 토큰의 서명에 저장된값을 통해 토큰을 테이터베이스나 쿠키에 저장하지 않고도 유효성 검사를 할 수 있다고 한다. 

### jwt 토큰의 서명
- 서명은 선택적인 부분이며, 생성된 토큰을 조직속 내부 애플리케이션과 공유할 때마다 선택적으로 포함시킬 수 있다.
- 만약 jwt 토큰이 조직속 내부 네트워크에서만 이동하는 것이 아니라, 외부의 엔드유저에게도 공유가 된다면, 헤더와 바디안에 담긴 아이디와 권한 값을 절대 변경하지 못하도록 해야할 것이다.
  - jwt 토큰 안에 담긴 값을 수정하지 못하도록 하는 역할이 바로 서명 부분이다.
- 만약 해커가 jwt 토큰에 담긴 자신의 권한을 admin으로 수정하려한다면 손쉽게 base64 디코딩과 인코딩을 통하여 jwt 토큰을 수정할 수 있을것이다.
- 그럼 어떻게 jwt 토큰 조작을 방지할 수 있을까
  - 새로운 jwt 토큰을 생성할 때마다, HMACSHA256과 같은 알고리즘의 도움을 받아 서명 부분을 작성하는 것이다.
  - HMACSHA256 알고리즘은 헤더, 바디 그리고 시크릿 값을 사용하여 서명부분을 만든다.
  - 입력 형식은 다음과 같다 HMACSH256(BASE64Encode(헤더) +"." + BASE64Encode(바디),시크릿값)
  - 해당 시크릿값이 무엇인지는 백엔드 어플리케이션에서만 알 수 있다.
  - 알고리즘의 출력은 전달된 값을 기반으로 한 무작위 해시 문자열이다.
  - 이제 해시 문자열은 서명 부분에 붙어 클라이언트에게 전송된다.
  - 이제 엔드유저가 jwt 토큰 값을 변경하려 한다면 손쉽게 이를 감지할 수 있을것이다.
- flow 차트를 통해 이해해 보자
- ![](jwt플로우차트.png)
- 1. jwt 토큰을 생성하여 엔드 유저에게 보낸다
  2. 엔드 유저는 jwt 토큰을 붙여서 특정 요청을 애플리케이션에 요청한다.
  3. 백엔드에서 jwt 토큰에 담긴 헤더값과 바디값, 시크릿 키를 활용하여 다시 한 번 해시값을 계산한다.
  4. 만약 계산된 해시값과 jwt 토큰 서명 부분에 담긴 값이 다르다면 조작됐다 판단하여 요청을 거부할 것이다.
  5. 따라서 jwt 토큰을 특정 세션이나 쿠키, 데이터베이스에 저장하지 않고서도 시크릿 값을 활용하여 검증을 진행할 수 있는것이다.
 

